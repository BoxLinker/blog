---
title: 关于构建下一代云原生应用的 5 个关键因素
date: 2017-06-29 12:56:13
tags:
- Kubernetes
- Cloud Native
---

不可否认，IT 在不断发生变化，它从向内关注处理自动化变化到向外关注提供业务。IT 正在从“支持业务”变化成“成为业务(be the business)”。

这对传统 IT 提出了很多挑战，包括开发、操作流程、学习一种语言和最小可行产品（MVP）、创建混合 IT 和商业的团队以及寻找这种正确的混合技巧。

在 IT 面对的所有挑战中，可能最重要的就是开发能够支持 “be the business” 的应用了。简单来讲，传统的应用架构、操作和开发步骤在新的模式下完全不够用。这种新的应用模式有一个常用的名字就是 “云原生应用”。用这个词来描绘这种具有高频发布周期和很难预测的高工作量并且使用 DevOps 来作为组间过程方法（inter-group process methodology）的应用还是比较贴切的。

## 云原生应用的 5 个关键因素
云原生应用的因素有哪些？下面是 5 个关键的部分：
* 应用设计（Application Design）：微服务架构
* API 的呈现（API exposure）：通过标准方法进行内部或者外部访问
* 操作集成（Operational Integration）：日志聚合和信息监控来做到应用管理
* DevOps：应用生命周期的自动化处理
* 测试（Testing）：在开发中使用 QA，保证产品质量（译者注：原文是 Changing the role and use of quality assurance ）

要想在生产环境中使用云原生应用的话，这几个部分都很重要。丢失了任何一个部分，都有可能会导致不能满足外部或者内部用户的应用需求。反之，如果满足了以上几个部分，就可以大大增加将合适的应用与重要的业务连接起来的可能性。

### 1. 应用设计：新兴的微服务架构

云原生应用的一个最大的需求就是速度：迅速的交付和遍历应用的功能。而在传统的应用架构中，所有的代码都被打包进了一个巨大的执行文件中，这也成为了最大的阻碍。

在一台服务器上只部署一个可执行文件是非常简单，但是也增加了开发的难度和复杂度。只要有一点代码变动，不管这个变动有多小，都需要重新构建整个可执行文件。这就会导致一连串的变动，包括项目集成和测试，就算没有变动的部分也需要走这个流程。在传统的 IT 团队中，这种集成和测试可能会持续将近两周。由于集成过程已经严格定义好了发布周期，所以开发团队必须在这个发布时间内去发布项目。由于这种架构的庞杂性会增加项目的发布和更新周期，所以也会拖慢公司对于市场需求的及时响应。

相比之下，由视频流服务提供商 NetFlix 开创的 [微服务方式](http://techbeacon.com/think-big-microservices-lego-software-development-takes-shape) 通过更改可执行的部署模型来减少集成和测试的重担。这种方式将一整个大的应用分散为多个独立的可运行的功能组件。

这种拆解方式，使得每一个功能组件的跟新和部署都不影响其他组件。相应的，这也会减少传统架构所带来的一些问题：
* 因为所有微服务的执行操作都是分离的，所以**每一个功能都可以通过相关联的微服务正确有序的独立更新**。比如一个跟业务相关的微服务功能（比如用户电子贸易申请）可以经常跟新，而不会影响其他不经常更新的服务（比如用户验证）
* **集成的准备工作会减少**，这会直接增加功能部署的次数。由于每个服务都是独立的，所以也不需要将它与其他微服务想结合。这会减少（或者排除）在集成上的精力，使新功能的迭代更新更加迅速。
* **更加容易掌控不可预测的工作量**。在整体应用架构下，应用环境需要安装整个可执行文件并将它加入应用池。使用这种大应用文件，会花费大量的时间，并且非常难统计工作量。并且如果其中一部分功能需要高负载，那么必然导致整个应用文件的重复部署，非常浪费资源。在微服务模式下，只需要弹性伸缩需要的功能组件就可以了，减少了部署时间和资源浪费。
* **测试更加简单了**，由于服务都根据功能模块分散开了，所以也就只需要测试确定的那单个功能就可以了。

当然，向微服务架构迁移也会带来一些需要解决的问题。主要有两个方面：一个是如何拆分功能为独立的服务，另一个就是每个独立的服务之间的通信问题。你也许知道第二个问题可以通过 API 连接解决，这一点我将会在下一章里说明。

### 功能分割
功能分割非常重要。微服务的分割处理得当的话可以加速功能迭代并且减少集成工作量，而且会强化应用监控和管理复杂度。更加粗略的分割微服务会使应用的监控和管理变得简单，但是由于大量的功能集合在了一起而需要更大的集成度。

一种分割服务的方法是根据应用本身的功能性来划分。比如，用户身份和用户验证一般是独立的而且被多个服务所公用，所以就需要把它做一个单独的服务。

还有一种策略是根据 “[康韦法则](https://en.wikipedia.org/wiki/Conway%27s_law)”，大概就是系统设计一般根据组织结构来确定。在微服务这里就意味着服务分割需要根据你的技术团队的组织结构来划分。如果你有一个“支付交易”团队，那将是一个比较好的微服务，按照这种思路可以划分整个团队。当然了，划分微服务架构必须确保这些结构都是有意义的，相反，根据微服务来划分团队也是很有挑战性的。

总之，向微服务靠拢非常重要而且在不断发展。微服务架构也能很好的支持云原生应用的特殊需求。

### 2. APIs 微服务之间如何通信
微服务应用架构的一个比较明显的问题就是不同服务之间该如何通信，如何发送以及返回数据。而且，另一个必要的问题就是面向客户端的 “前端” 服务该如何返回用户从浏览器等各种终端发送的请求。

一种解决办法就是使用 [RESTFul APIs](https://en.wikipedia.org/wiki/Representational_state_transfer) 来处理基于微服务的应用之间的通信。这种 APIs 提供一种标准的供用户调用的接口协议。这将使调用变的简单，不管是内部调用还是外部调用，都可以统一调用格式。

每一个服务都将 APIs 当成是 “合同” 。如果一个调用的格式正确，并且有正确的鉴定和验证，也附带着正确格式的数据，服务就会执行并且返回相应的结果。从概念上讲，APIs 非常简单直接，但是在实践应用中，还是有几点需要注意，包括：

* API 版本：微服务的一个好处就是它能够确定功能的更新频率。有时，由于额外的请求参数或者不同的返回数据类型都有可能导致新版本的功能需要一个新的 API 格式。如果在原有 API 的基础之上更新是一个不好的做法，因为在调用者更新到了新版本之前，请求都是访问不通的。所以，你需要保持现有的 API 存在的情况下，再提供一个新版本的 API。
* 负载：太多的请求将会导致服务响应变慢，削弱应用的整体表现。而且，还会发生 DDoS 攻击的可能。所以，很有必要模拟 APIs 调用来减少在高负载请求的情况下发生拒绝请求的事情发生。
* 断路器（Circuit breakers）：服务有可能并不能即时的对合法请求做出响应。由于某一个微服务响应太慢会影响整体应用的表现，所以断路器在每个微服务中就比较重要了。断路器会在监控服务的响应时间，如果时间太长，它将会停止处理请求，而直接返回一个备用数据，以便其他微服务能够顺利执行下去。当然了，这就需要应用的设计者构建这样的备用数据服务，并且在需要的时候能够返回备用数据。
* 数据缓存：断路器需要数据缓存的支持，但是你也可以在应用执行中使用它。如果服务的部分数据变化并不是很频繁（比如用户的家庭地址），那么你就可以把它缓存起来使用，而不是去实时查库。

这几点阐述了向微服务迁移时需要做的几点要求，而并不仅仅是暴露一个接口机制。尽管比较复杂，但是它灵活、方便、比其他的接口机制都要方便。


### 3. 运行环境设计（Operational design）: 看起来简单，实际上更复杂了
传统运行环境的一个巨大挑战就是将新代码合并到生产环境当中。由于庞大的应用架构合并到一个可执行服务中，新代码的发布需要部署整个应用环境。通常情况下，这将导致一些问题：
* 生产环境与开发环境有本质上的区别。开发者在生产环境出问题是常说的一句经典用语就是：在我的环境上跑的好好的啊。
* 在不把整个环境切换到新版本的情况下而在生产环境中测试新功能是很具有挑战性的。这一点是发布新代码的一个主要工作。
* 大多数生产环境在发布新代码之后是没有办法回退回去的，所以如果代码出现了问题，就会紧急重建之前的版本。

微服务架构会极大的简化这个过程。

由于环境被分割了，代码都被分割到了独立的微服务中，这就允许单个的微服务更新是不会影响其他的微服务。这就使得代码回滚变得非常简单、容易而且风险小。

不仅如此，大多数的微服务环境对于每一个微服务都有冗余服务，所以可以实现的就是在微服务池中用新版本的服务去替代旧版本的服务。总体上讲，微服务架构可以在环境运行中进行服务的版本更新。

除此之外，由于微服务使用 APIs 通信，你可以通过暴露新版本的 API 来暴露新服务。当你在调试新功能时，发现新服务有问题，你可以通过 API 管理系统来关掉新版 API 并确保旧版的 API 任然可用。这将使你在庞杂的代码更新中，定位到大多数的问题所在，并能实现代码回滚。

当然微服务也不是万能的。这种新的应用架构也伴随着诸多挑战，它需要你准备好新的监控和管理系统能够处理这种应用架构。

最直接的一个问题就是一个大的应用由这么多的可执行的服务构成，监控和管理系统就必须能够收录和展示它们并且能够运行良好。

关于监控和管理系统有几点需要注意的地方：

* **动态的应用网络**。在生产环境中，微服务实例的启动和关闭表现在整体应用层面就是代码更新、应用可用和应用不可用（比如：网络上的微服务不能正常访问了）。由于实例是短暂存在的，应用监控和管理架构就必须能够非常灵活的让微服务实例加入或退出应用网络。
* **中心化处理日志以及监控信息**。服务实例的短暂存留的特性决定了它们产生的日志以及监控记录是不能持久存在的。为了保证应用信息可用，很有必要将这些信息发送到一个中心化的地方持久存储起来。一般情况下，会使用非结构化的数据库来实时处理这些数据。而且这种中心服务也提供查询、分析以及时序对比功能 (e.g., looking for all days in which an application experiences 200 percent traffic spikes)。
* **根源问题分析**（Root cause analysis）。不可否认，微服务架构比传统的整体服务架构更加复杂。这就意味着一个服务表面发生的问题，可能隐含在了应用的更深层次上。比如一个用户接收的错误，很有可能根源上是发生在了服务的缓存层上。 这就使得鉴别服务问题的根本原因更加复杂，反过来，这也催生了中心化处理日志和监控的需求。当你中心化整理了所有不同服务的日志信息时，就有可能看到当一个用户可见的错误发生时，一个服务缓存错误随之发生，这样你就可以更加有目的的在正确的地方进行调试了。

尽管微服务架构增加了系统的额外复杂度，但是开发者也应该有选择性的根据他们现有的服务体系来升级或者替换系统。微服务架构在面向业务需求方面的优势显而易见，这种应用方式也将在未来 5 年成为主流架构模式。

### 4. DevOps：未来应用的工作台（Table stakes）
如今的 IT 企业都有明确的分组，每个组都负责某一个部分应用的生命周期，包括，开发，应用构建，QA，部署和运维。但是，各个组都有自己唯一的专注于内部优化的流程。这直接导致组与组之间的交接必须手动操作，每个组都必须在新的运行环境下重新创建一个新的整体应用。通常情况下，组与组之间交接任务需要非常长的时间。这些 IT 架构会大大增加部署时间，而在新的要求快速部署和更新的 IT 世界里，这将会成为灾难。

DevOps 尝试打破这些 IT 组织的壁垒，并且成为手动操作的一个关键替代因素。在 DevOps 中，目标就是尽可能的减少从程序员写代码到部署到生产环境之间的时间。

实现 DevOps 还不是那么容易的。大多数公司采用如下两种方式：

* **解决相对比较大的应用生命周期中的痛点。**比如，QA 经常很难获取到足够的资源，在实际开始测试之前他们需要服务器、安装配置软件并且测试新代码。这就是说他们在实际反馈给开发者之前需要耗费大量的精力。一些公司将测试转到云环境上，在那里 QA 可以快速的获取他们需要的资源。更有甚者会让开发自己写测试用例来测试自己的新代码。这就意味着，质量评估放在了开发过程中解决，而不是开发完成后交给测试部门。
* **通过一种叫做 VCM（value chain mapping）的技术来访问整体应用生命周期。**VCM 会检查整个应用生命周期，辨别哪些组涉及其中，每个组都做了什么，并且获取每个组的任务需要花多久。之后每个组再规划出他们各自独立流程的流水线，当然这就需要所有组统一检查方法来避免手工维护。

大多数 IT 企业用了 DevOps 之后就会发现他们需要用 VCM 来检查整个应用的生命周期。原因就是：流水线化或者说自动化某一个组的工作而不管其他组的话并不能明显的加速整体应用的交付时间。之后实施了 VCM 之后，并且尽量优化每一个环节，并且处理好组与组之间的自动化流程才是 IT 企业能够适应 “be the business” 的需求。

DevOps 的效果是激动人心的。大多数的 IT 企业会发现，他们的发布流程可能会从之前的不到 6 周缩减为 1 周或者更少。DevOps 的典型案例 Amazon 可以做到每小时上百次更新。尽管这很厉害，但是大多数企业只需要做到每周或者每天就够了。

### 测试：A dramatic restructuring
在大多数的 IT 公司里，测试都被 QA 所代替，并且人员短缺资金不足。这就就导致了测试工作都由手工操作。此外，多数 IT 公司的测试工作就在部署之前进行，并且很简单。

这种方式也许在 “support the business” 下勉强行得通，但是在 “be the business” 下则完全行不通。测试工作绝不是事后去做的。QA 测试工作必须是开发流程中的一个核心环节，并且必须是越早进行越好，这样才能尽早的暴露出应用中的一些严重问题。

测试的主要途径就是在开发生命周期中尽早的介入进来。功能测试交给开发去做，谁写的代码谁去测试功能。

然而，要做到这一步不仅仅是将手动工作从一个组交接到另一个组。你还需要创建一个当有新代码进来的时候能够去调用的自动测试执行环境。当开发者提交代码的时候，the code repository should automatically kick off a set of functional tests that test all of the code associated with the portion of the code on which the developer has been working. （没看懂 >_< ）

这种由开发者驱动的方式将促使 QA 聚焦在测试的其他 3 个方面，而这 3 个方面在传统模式下常常被忽略，并且在 “be the business” 中变的越来越重要。
* **集成测试。**这是一种应用的端到端测试，并且关注应用的每一个部分。集成测试确保在新代码加入的时候不会对已有的代码产生任何不经意之间的错误影响。你可以在代码进入系统的初始化过程里自动化处理，而这也可以在生产环境中很有效的避免一些不可预期的错误。实现一个集成测试环境需要自动化测试的能力，测试资源以及开发周期。
* **客户端测试。**随着移动端设备的访问量剧增，各种型号的移动端设备测试至关重要。大多数 IT 公司都会有一个 “移动端实验室” 购买一些移动端设备来做测试，但是他们很快就会发现他们很难追赶上新型号的面世速度。所以大多数公司开始转向移动测试服务，这种服务提供外部的设备并且很全面又有足够的资源来应对测试量。
* **表现/负载测试。**云原生应用就好比传统云服务一样需要能够处理不可预测的高访问量。许多应用之所以在高访问量下失败或表现欠佳，要么有一些功能瓶颈，要么就是没有考虑弹性伸缩设计。在 “be the business” 世界里，应用表现欠佳会严重影响公司的品质，所以表现/负载测试在云原生应用中扮演这核心的角色。

### Be the business
如今的时代，对于 IT 企业来说是最好的时代但也是最坏的时代。

随着商业进入数字时代，IT 也从 “suport the business” 往 "be the business" 转变。传统 IT 企业已经被排除到了核心商业的外围。但是由于很多企业已经深陷老式的过程和组织功能化的泥潭，他们需要做出的改变也是巨大的。这方面转型成功的关键 5 点上面已经列出了。只有这样做 IT 企业才能够真正满足 “be the business” 商业模式并且转型他们的业务。

[原文链接](https://techbeacon.com/building-next-generation-cloud-native-apps-essential-guide)
